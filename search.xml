<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在NOIP2017之后</title>
    <url>/2017/after-noip-2017/</url>
    <content><![CDATA[<h3 id="引">引</h3>
<blockquote>
<p>本来应该有另一篇博客叫做写在NOIP2017之前的, 但跑回家才意识到博客搭在机房的电脑上, 于是......</p>
</blockquote>
<a id="more"></a>
<h3 id="比赛过程">比赛过程</h3>
<h4 id="day1">Day1</h4>
<p>看到这个T1不送分了, 心里还是有点虚, 认真地读完了后面两题平复了一下心态. 想着既然是T1, 肯定不是送就是偷, 看着样例找了找规律, 推了个 <span class="math inline">\(a + b + (b \% a) (a &lt; b)\)</span> 的方法, 发现过不了大样例. 于是盯着大样例发呆, 突然发现了世界的奥秘. 然后写T2, 写完眼查了一下大样例, 正要关闭窗口的时候 Vimdiff 了一波, 发现自己大小写写错一大堆... T3想了想写了个不考虑零边的记忆化搜索, 发现大样例过不了 认真思考了一下发现是没有考虑到达终点又折返的情况 又想了想发现 <span class="math inline">\(-1\)</span> 挺好判的, 就加上了.</p>
<h4 id="day2">Day2</h4>
<p>到达考场时精神状态不太好, 意识模糊地打开了题目. 看完T2一直在想MST什么的, 感觉不太会做准备放弃时发现数据范围只有12, 于是秒懂了. T3没想多久推出一个平衡树的做法, 对自己代码能力过于自信没有多想就开始写, 结果调到最后一刻还是GG了.</p>
<h3 id="反思错误">反思错误</h3>
<p>感觉这次虽然题目比较奇怪, 但实际难度还是合理的, 出现了一些失误恰恰暴露出身上的一些问题.</p>
<ul>
<li>考试的时候大部分处在一种边想边写的状态, 一边写可能还要一边完善一些细节.</li>
<li>刷了很多Atcoder 的题目之后, 代码能力退化明显.</li>
<li>考场的debuff比较强.</li>
</ul>
<p>可能后面两条还稍微可以接受吧, 但是第一条的确是硬伤, 这样做简单题或者在比较清醒的时候写题可能还好, 然而一旦遇到代码实现比较复杂或者条件比较多的题目, 就会挂得很惨, 这个问题模拟赛中也出现过几次. 解决的策略其实说起来也不难, 主要就是每道题写之前把算法细节考虑基本清楚, 做到 <code>Think twice, Code once</code> 吧. 这样也不会出现某道题写了很久最后发现做法是错误的这种尴尬的情况也能够避免写一些特别复杂的做法.</p>
<h3 id="关于未来">关于未来</h3>
<p>针对这次联赛的问题和原来的一些弱点, 对接下来的一段学习做一些规划：</p>
<ul>
<li>补一些数学相关的知识（不一定OI相关）</li>
<li>提高一下代码能力, 复习一些不熟练的数据结构, 刷一些质量比较高的题目</li>
</ul>
<p>然后的话, 回去就要补文化了吧.</p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>平面树计数</title>
    <url>/2017/count-plane-tree/</url>
    <content><![CDATA[<p>不常见的经典问题, 顺便总结一下Burnside引理吧.</p>
<a id="more"></a>
<h3 id="问题描述">问题描述</h3>
<blockquote>
<p>给定 <span class="math inline">\(N\)</span>, 求 <span class="math inline">\(N\)</span> 个点的本质不同的平面树的数量. 两棵平面树是等价的当且仅当其中一棵能够移动点的位置与另一棵重合, 且过程中仍然是一棵平面树.</p>
</blockquote>
<h3 id="做法">做法</h3>
<p>考虑模型转化(计算 <span class="math inline">\(N+1\)</span> 个点的答案): 取单位圆, 等距地取 <span class="math inline">\(2N\)</span> 个点, 然后将这些点两两配对连边, 满足所有连边不相交. 发现它的对偶图恰好是一棵平面树, 像这样:</p>
<p><img src="/img/plane-tree.png"></p>
<p>那么就只需要考虑本质不同的这样的配对的数量即可. 两个圆是等价的当且仅当一个圆可以通过旋转一定的角度与另一个圆重合. 而在这个圆上共有 <span class="math inline">\(2N\)</span> 个点, 就意味着有 <span class="math inline">\(2N\)</span> 个置换, 构成一个置换群.</p>
<p>置换群下的计数可以用到 Burnside引理 :</p>
<blockquote>
<p><span class="math display">\[ N(G, C) = \frac{1}{|G|} { \sum_{f \in G} c(f) } \]</span></p>
</blockquote>
<p>则转化为求置换下的不动点的数量:</p>
<ul>
<li><p>不存在置换的情况下, 答案为 <span class="math inline">\(C_N\)</span>, <span class="math inline">\(\mathrm{Catalan}\)</span> 数的第 <span class="math inline">\(N\)</span> 项. 即将相互匹配的位置看作左右括号, 则所有合法的括号序列都对应一个满足条件的圆.</p></li>
<li><p><span class="math inline">\(N\)</span> 为奇数时, 可能存在一条平分圆的对角线在置换下不变, 计算 <span class="math inline">\(\frac{N+1}{2}\)</span> 个点的答案即可.</p></li>
<li><p>考虑旋转置换:</p>
<p>为了满足旋转之后的边重合, 点 <span class="math inline">\(i\)</span> 和它的匹配点 <span class="math inline">\(p_i\)</span> 在旋转后应该仍然是相匹配的. 则环的数量一定是偶数 <span class="math inline">\(2d\)</span>, 所以环的长度可以表示为 <span class="math inline">\(\frac{2N}{2d} = \frac{N}{d}\)</span>.</p>
<p>假定置换的阶是 <span class="math inline">\(e\)</span>, <span class="math inline">\(e &gt; 1, e | N\)</span>, 环的数量 <span class="math inline">\(2d = \frac{2N}{e}\)</span>. 环上与 <span class="math inline">\(0\)</span> 匹配的点为 <span class="math inline">\(i\)</span>, 不难发现在这些点之间的点的方案数为 <span class="math inline">\(C_{i-1}\)</span>. 当这些点确定之后, 它们在环上依次经过的 <span class="math inline">\(e(i+1)\)</span> 个点就确定了.</p></li>
</ul>
<p>令 <span class="math inline">\(f(x)\)</span> 表示 <span class="math inline">\(\mathrm{Catalan}\)</span> 数的生成函数, 根据 <span class="math inline">\(\mathrm{Catalan}\)</span> 数的递推式, 不难得到:</p>
<p><span class="math display">\[ f(x) = xf^2(x) + 1 \]</span></p>
<p>构造 <span class="math inline">\(B_d\)</span> 表示包含 <span class="math inline">\(2d\)</span> 个环的置换下不动点的数量.</p>
<p><span class="math display">\[ B_d = 2\sum_{i = 0}^{d-1} C_i B_{d-i-1} \]</span></p>
<p>其中因子 <span class="math inline">\(2\)</span> 考虑的是 <span class="math inline">\(i &gt; 2d\)</span> 时用当前置换的逆来计算的情况.</p>
<p>则 <span class="math inline">\(B_d\)</span> 的生成函数 <span class="math inline">\(g(x)\)</span> 满足:</p>
<p><span class="math display">\[ g(x) = 2x g(x) f(x) + 1 \]</span></p>
<p>解得:</p>
<p><span class="math display">\[ g(x) = (1 - 4x) ^ {-\frac{1}{2}} \]</span></p>
<h3 id="问题解决">问题解决</h3>
<p><span class="math display">\[ p(n) = \frac{1}{2n} \left( [\mathrm{n \, is \, odd}]\binom{n}{\lfloor\frac{n}{2}\rfloor} - \binom{2n}{n-1} + \sum_{d|n}{\varphi(n/d)\binom {2d}{d}} \right)\]</span></p>
]]></content>
      <tags>
        <tag>Burnside</tag>
        <tag>Combinatorial</tag>
        <tag>Generating Function</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder 选做</title>
    <url>/2017/atcoder-select/</url>
    <content><![CDATA[<p>其实是总结一下比赛中遇到的好题, 然后瞎做了几场 AGC 的题目练习, 感觉还比较有意思.</p>
<a id="more"></a>
<h3 id="agc">AGC</h3>
<h4 id="agc002-f-leftmost-ball">AGC002 F Leftmost Ball</h4>
<blockquote>
<p>给你<span class="math inline">\(N\)</span>种不同颜色的球, 每种有<span class="math inline">\(K\)</span>个, 现在你可以将球任意排列, 但最终的序列中每种颜色的第一个出现位置要被染成<span class="math inline">\(0\)</span>颜色, 求能够得到的本质不同的序列数, 对<span class="math inline">\(10^9 + 7\)</span>取模.</p>
</blockquote>
<p><span class="math inline">\(N, K \leq 2000\)</span></p>
<p>这题正着处理没有什么思路, 但是如果从右往左来会比较好考虑. 我们可以记<span class="math inline">\(f(i, j)\)</span>表示当前从右往左填剩下<span class="math inline">\(i\)</span>个<span class="math inline">\(0\)</span>颜色的球, 还剩下<span class="math inline">\(j\)</span>种颜色没有放的方案数. 那么每一次的决策就包括放入一个<span class="math inline">\(0\)</span>颜色的球以及添加一种颜色的<span class="math inline">\(k-1\)</span>个球:</p>
<p><span class="math display">\[
\begin{aligned}
    f(i-1, j) &amp; \leftarrow f(i, j) \mid [i &gt; j] \\
    f(i, j-1) &amp; \leftarrow f(i, j) \times {n-i + (n-j) \times (k-1) + k-2 \choose k-2}
\end{aligned}
\]</span></p>
<blockquote>
<p>后面那个公式是可重集, 还有最后的答案要乘以<span class="math inline">\(n!\)</span>.</p>
</blockquote>
<h4 id="agc005-d-k-perm-counting">AGC005 D ~K Perm Counting</h4>
<blockquote>
<p>求长度为<span class="math inline">\(N\)</span>的排列中, 满足对任意的<span class="math inline">\(i\)</span>, 都有<span class="math inline">\(|a_i - i| \neq K\)</span>的排列数量.</p>
</blockquote>
<p><span class="math inline">\(1 \leq K &lt; N \leq 2000\)</span></p>
<p>考虑容斥, 计算至少有<span class="math inline">\(i\)</span>个位置不合法的方案数. 由于<span class="math inline">\(K\)</span>是确定的, 那么所有不合法的方案可以看成是完全二分图匹配中出现了一条<span class="math inline">\((i, i+k)\)</span>的边或者一条<span class="math inline">\((i, i-k)\)</span>的边.</p>
<p>将这样的边在画出来就是若干条交叉路径. 观察到这样的交叉路径不相交, 所以可以拆开拼成一个序列, 然后在序列上<span class="math inline">\(dp\)</span>即可.</p>
<h4 id="agc015-d-a-or...or-b-problem">AGC015 D A or...or B Problem</h4>
<blockquote>
<p>求在<span class="math inline">\([A, B]\)</span>中任意选出一个非空整数集合的元素位或和有多少种不同的答案.</p>
</blockquote>
<p><span class="math inline">\(1 \le A \le B \le 2^{60}\)</span></p>
<p>先考虑一些比较特殊的情况(以下默认<span class="math inline">\(A, B\)</span>的位数相同):</p>
<ul>
<li>当<span class="math inline">\(B\)</span>可以表示为<span class="math inline">\(2^k - 1\)</span>时, 这个位或和恰好取遍<span class="math inline">\([A, B]\)</span>之间的所有整数.</li>
<li>当<span class="math inline">\(A\)</span>可以表示为<span class="math inline">\(2^k\)</span>时, 这个位或和在区间<span class="math inline">\([A, A + 2^{t+1}) \mid t &lt; \log_2 A\)</span>中, 其中<span class="math inline">\(t\)</span>是最大的满足<span class="math inline">\(B\)</span>的第<span class="math inline">\(t\)</span>位为<span class="math inline">\(1\)</span>的数.</li>
</ul>
<p>那么一般情况下这些条件有什么用呢?</p>
<p>我们考虑找到最大的一个<span class="math inline">\(T\)</span>,使得<span class="math inline">\(B\)</span>的第<span class="math inline">\(T\)</span>位为<span class="math inline">\(1\)</span>且<span class="math inline">\(A\)</span>的第<span class="math inline">\(T\)</span>位不为<span class="math inline">\(1\)</span>, 记<span class="math inline">\(K = 2 ^ T\)</span>. 当选择的数的集合在<span class="math inline">\([A, K)\)</span>以及在<span class="math inline">\([K, B]\)</span>中的情况可以直接用上述结论.</p>
<p>接下来考虑同时选取两个集合中的数可能会产生的答案. 因为这时小于<span class="math inline">\(K\)</span>的部分是没有贡献的, 所以直接将<span class="math inline">\([A, K)\)</span>中的所有答案取出. 不难发现<span class="math inline">\([K, B]\)</span>中取任意个都与只使用<span class="math inline">\(K\)</span>没有区别, 那么这时候的范围是<span class="math inline">\([K+A, 2\times K-1]\)</span>, 注意减去重复贡献.</p>
<h4 id="agc015-f-kenus-the-ancient-greek">AGC015 F Kenus the Ancient Greek</h4>
<blockquote>
<p><span class="math inline">\(Q\)</span> 组询问, 每组询问的形式为A, B, 表示求<span class="math inline">\(x \in [1, A], y \in [1, B]\)</span>的<span class="math inline">\(g(x, y)\)</span>的最大值, 及最大值的方案数, 其中:</p>
</blockquote>
<p><span class="math display">\[
g(x, y) = 
\begin{cases} 
    1, &amp; \text{y = 0} \\
    g(y, x), &amp; \text{x &gt; y} \\
    g(y \; mod \; x, x) + 1, &amp; \text{otherwise} \\
\end{cases}
\]</span></p>
<p><span class="math inline">\(1 \le Q \le 3 \times 10 ^ 5 \,\,, 1 \le A, B \le 10 ^ {18}\)</span></p>
<p><strong>以下无特殊说明, 均默认所有<span class="math inline">\(x &lt; y, A &lt; B\)</span></strong> 先考虑第一问, 如果我们由一个特定的<span class="math inline">\((x, y)\)</span>, 从小到大地构造使得<span class="math inline">\(g(x, y)\)</span>的值不断地变大, 那么如何构造使得这个值最大呢? 对于所有<span class="math inline">\((x&#39;, y&#39;)\)</span>满足<span class="math inline">\(g(x&#39;, y&#39;) = g(x, y) + 1\)</span>, 显然有:</p>
<p><span class="math display">\[
(x&#39;, y&#39;) \in \{ (y, x + ky) \mid k \in Z^+ \} 
\]</span></p>
<p>同时, 为了使得这个过程尽可能的多次进行,我们从<span class="math inline">\((0, 1)\)</span>出发, 每次取<span class="math inline">\(k = 1\)</span>. 发现这样生成了一组<span class="math inline">\(Fibonacci\)</span>数列, 这里<span class="math inline">\(Fibonacci\)</span>数列从0开始标号. 那么第一问的答案就是求满足<span class="math inline">\(Fib_k \le A,\; Fib_{k+1} \le B\)</span>的最大的<span class="math inline">\(k\)</span>. 同时, 这样的数对是满足<span class="math inline">\(g(x, y) = k\)</span>的最小的数对. 接下来考虑统计方案数. 首先, 对于一组询问我们只需考虑其中<strong>与最优解相关</strong>的<span class="math inline">\((x, y)\)</span>. 考虑所有最优的<span class="math inline">\((x, y)\)</span>会具有的性质:</p>
<ul>
<li><span class="math inline">\(x \ge Fib_k, \; y \ge Fib_{k+1}\)</span></li>
<li>不存在一组<span class="math inline">\((x&#39; &lt; x, y&#39; &lt; y)\)</span>, 使得<span class="math inline">\(g(x&#39;, y&#39;) &gt; g(x, y)\)</span></li>
</ul>
<p>然而这样的<span class="math inline">\((x, y)\)</span>并不一定是最优的. 我们接着分析所有在最优解的<span class="math inline">\(g\)</span>的计算路径上的数对<span class="math inline">\((x, y)\)</span>的性质: 不难发现, 经过一次变化后得到的<span class="math inline">\((x&#39;, y&#39;)\)</span>, 一定满足:</p>
<ul>
<li><span class="math inline">\(g(x&#39;, y&#39;) = k-1\)</span></li>
<li><span class="math inline">\(x&#39; \ge Fib_{k-1}, y&#39; \ge Fib_{k}\)</span></li>
<li><span class="math inline">\(y&#39; \le Fib_{k+1} + Fib_{k-2}\)</span></li>
</ul>
<p>后面条件的解释: 若<span class="math inline">\(y&#39; &gt; Fib_{k+1} + Fib_{k-2}\)</span>, 则: <span class="math display">\[(x, y) = (y&#39; &gt; Fib_{k+1} + Fib_{k-2} &gt; Fib_{k+1}, x&#39; + py&#39; \ge x&#39; + y&#39; &gt; Fib_{k+2})\]</span> <span class="math inline">\((x, y)\)</span>不再满足上述最优性质2, 矛盾. 同时每次向下一步进行构造的时候只有<span class="math inline">\((Fib_k, Fib_{k+1})\)</span>可能取到<span class="math inline">\(p = 2\)</span>所以这样的数对个数是<span class="math inline">\(O(k)\)</span>的. 所以我们预处理所有的这样的数对, 然后用除法算下答案就好了. 复杂度<span class="math inline">\(O(\log^2{MAX} + Q\log MAX)\)</span>.</p>
<h3 id="arc">ARC</h3>
<p>ARC 的题目主要来源是打过的几场比赛, 暂时不多.</p>
<h4 id="arc074-e-rgb-sequence">ARC074 E RGB Sequence</h4>
<blockquote>
<p>给你一个长度为<span class="math inline">\(N\)</span>的序列和<span class="math inline">\(M\)</span>组约束条件, 每组条件形如<span class="math inline">\(L_i, R_i, X_i\)</span>, 表示序列上的<span class="math inline">\([L_i, R_i]\)</span>中恰好有<span class="math inline">\(X_i\)</span>种颜色, 现在要你用三种颜色给这个序列染色, 求满足所有约束的方案数.</p>
</blockquote>
<p><span class="math inline">\(1 \le N, M \le 300\)</span></p>
<p><span class="math inline">\(dp\)</span>的思路应该比较显然, 然而普通的状态表示不太好处理. 我们记<span class="math inline">\(dp_{r, g, b}\)</span>表示三种颜色的球最后一次出现的位置分别是<span class="math inline">\(r, g, b\)</span>时的方案数.</p>
<p>然后考虑状态的合法性, 可以把条件存在<span class="math inline">\(R_i\)</span>的位置. 当选择一个状态时, 考虑这个状态的最末位的所有约束即可.</p>
<h4 id="arc077-f-ss">ARC077 F SS</h4>
<blockquote>
<p>定义一个字符串为偶的, 当且仅当这个字符串能够被分成两个完全相同的字符串.</p>
</blockquote>
<p>定义函数<span class="math inline">\(f(s)\)</span>, 其中<span class="math inline">\(s, f(s)\)</span>均是字符串,<span class="math inline">\(f(s)\)</span>为在字符串<span class="math inline">\(s\)</span>后添加非空的字符满足新串为偶且长度最小的串. 现在给你串<span class="math inline">\(s\)</span>(初始为偶的), 求<span class="math inline">\(f^{10^{100}}(s)[L, R]\)</span>中各个字母的出现次数. <span class="math inline">\(1 \le |S| \le 2\times 10^5\)</span> <span class="math inline">\(1 \le L \le R \le 10^{18}\)</span></p>
<p>首先对于一个给定的<span class="math inline">\(s\)</span>, 其<span class="math inline">\(f(s)\)</span>必定唯一. 考虑每次最少加一个字符,<span class="math inline">\(f^{10^{100}}(s)\)</span>就等价于一个长度无穷的字符串. 这个答案的形式显然可以前缀和, 又因为<span class="math inline">\(s\)</span>在变化过程中始终是偶的, 实际上我们只需要关注左半部分的字符.</p>
<p>我们从最简单的一次操作来考虑. 记初始的字符串<span class="math inline">\(s\)</span>为<span class="math inline">\(SS\)</span>, 记一次变化之后左边的部分为<span class="math inline">\(ST\)</span>, 那么得到的新串就是<span class="math inline">\(STST\)</span>. 要使得加的字符长度最小, 就要在<span class="math inline">\(S\)</span>中找到最长前后缀匹配长度, 这时<span class="math inline">\(T\)</span>就是<span class="math inline">\(S\)</span>去掉最长匹配后缀所得.</p>
<p>我们发现, 每次操作都等价于找到前后缀匹配最大长度(当然要小于<span class="math inline">\(|S|\)</span>), 然后将剩下部分的前缀<span class="math inline">\(T\)</span>添加到<span class="math inline">\(S\)</span>的末尾.</p>
<ul>
<li>当<span class="math inline">\(|T| \mid |S|\)</span>时,<span class="math inline">\(|S|\)</span>有长为<span class="math inline">\(|T|\)</span>的最小周期, 每次加入的<span class="math inline">\(|T|\)</span>相同.</li>
<li>当<span class="math inline">\(|T| \nmid|S|\)</span>时, 我们<del>通过打表</del>发现, 这样的<span class="math inline">\(T\)</span>是在有规律地变化的, 因为每次加入<span class="math inline">\(T\)</span>之后的串前后缀最长匹配一定是<span class="math inline">\(|T|\)</span>, 否则的话, 上一步中最长匹配的性质就不一定会满足.</li>
</ul>
<p>然后我们得到了一个<span class="math inline">\(Fibonacci\)</span>数列? 直接暴力算就好了... 实际上第一种情况也可以直接算, 因为整个序列都是<span class="math inline">\(T\)</span>的若干次重复得到的.</p>
]]></content>
      <tags>
        <tag>Summary</tag>
        <tag>Combinatorial</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>A Brief Proof of Birthday Paradox</title>
    <url>/2020/birthday-paradox/</url>
    <content><![CDATA[<h1 id="introduction"><em>Introduction</em></h1>
<h2 id="birthday-paradox"><em>Birthday Paradox</em></h2>
<blockquote>
<p>There are <span class="math inline">\(k\)</span> people whose birthdays are among set <span class="math inline">\(B\)</span> with size <span class="math inline">\(n\)</span>, the probability that there are <strong>at least</strong> a pair of people have the same birthday is greater than <span class="math inline">\(\frac{1}{2}\)</span> when <span class="math inline">\(k \ge 1.2 \sqrt{n} + 1\)</span></p>
</blockquote>
<a id="more"></a>
<h1 id="proof"><em>Proof</em></h1>
<p>Suppose each person's birthday is <strong>independent uniform</strong> in <span class="math inline">\(B\)</span>, then the probability that don't exist such a pair is:</p>
<p><span class="math display">\[
P = \prod_{i=0}^{k-1} \left(1 - \frac{i}{n}\right)
\]</span></p>
<p>to prove <span class="math inline">\(P \le \frac{1}{2}\)</span>, we use the result in analysis that:</p>
<blockquote>
<p><span class="math inline">\(\forall x \in \mathbb{R}, 1 + x \le \mathrm{e}^x\)</span> <img src="/img/exp.png"></p>
</blockquote>
<p>then:</p>
<p><span class="math display">\[
\begin{aligned}
P &amp;\le \exp \left(\sum_{i=0}^{k-1} -\cfrac{i}{n}\right) \\
&amp;\le \exp \left(-\frac{(k-1)^2}{2n}\right) \\
&amp;\le \exp \left(-\frac{(1.2 \sqrt{n})^2}{2n}\right) \\
&amp;= \exp(-0.72) &lt; \frac{1}{2} \\
\end{aligned}
\]</span></p>
]]></content>
      <tags>
        <tag>Probability</tag>
        <tag>Real Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathematical Problems</title>
    <url>/2020/exercise-of-thoughts/</url>
    <content><![CDATA[<h2 id="preface">Preface</h2>
<p>Some interesting problems about Number Theory, Combinatics, Analysis or Algebra.</p>
<a id="more"></a>
<h2 id="basel-series">Basel Series</h2>
<p>Calculate</p>
<p><span class="math display">\[
\sum_{n=1}^{\infty} \frac{1}{n^2} = 1 + \frac{1}{2^2} + \frac{1}{3^2} + \dots
\]</span></p>
<h3 id="analytical-perspective">Analytical Perspective</h3>
<p>First notice that：</p>
<p><span class="math display">\[
\begin{aligned}
    I=&amp;\int_0^1 \mathrm{d} x \int_0^1 \frac{1}{1-xy} \mathrm{d} y \\
    =&amp;\iint_D \sum_{i=0}^{\infty} (xy)^i \mathrm{d}x\mathrm{d}y \\
    =&amp;\sum_{i=0}^{\infty} \iint_D (xy)^i \mathrm{d}x\mathrm{d}y \\
    =&amp;\sum_{i=0}^{\infty} \left(\int_0^1 x^i \mathrm{d} x\right)^2 \\
    =&amp;\sum_{i=1}^{\infty} \frac{1}{i^2}
\end{aligned}
\]</span></p>
<p>Now just need to calculate <span class="math inline">\(I\)</span>，replace variables：</p>
<p><span class="math display">\[
\begin{cases}
    x = u + v \\
    y = u - v
\end{cases},
\frac{\partial(x, y)}{\partial(u, v)} = \left|\begin{matrix} 1 &amp; 1 \\ 1 &amp; -1 \end{matrix} \right| = -2
\]</span></p>
<p>then：</p>
<p><span class="math display">\[
\begin{aligned}
I &amp;= 2 \iint_{D_{uv}} \frac{1}{1 - u^2 + v^2} \mathrm{d} u \mathrm{d} v \\
&amp;= 4 \left(\int_0^{\frac{1}{2}} \mathrm{d} u \int_0^{u} \frac{1}{1-u^2+v^2} \mathrm{d} v + \int_{\frac{1}{2}}^{1} \mathrm{d}u \int_0^{1-u} \frac{1}{1-u^2+v^2} \mathrm{d} v\right) \\
&amp;= 4 \left(\int_0^{\frac{1}{2}} \frac{1}{\sqrt{1-u^2}} \arctan \frac{u}{\sqrt{1-u^2}} \mathrm{d} u + \int_{\frac{1}{2}}^{1} \frac{1}{\sqrt{1-u^2}} \arctan \frac{1-u}{\sqrt{1-u^2}} \mathrm{d} u\right) \\
&amp;= 4 \left(\int_0^{\frac{1}{2}} \arctan \frac{u}{\sqrt{1-u^2}} \mathrm{d} \arctan \frac{u}{\sqrt{1-u^2}} 
  -2       \int_{\frac{1}{2}}^1 \arctan \frac{1-u}{\sqrt{1-u^2}} \mathrm{d} \arctan \frac{1-u}{\sqrt{1-u^2}} \right) \\
&amp;= 4 \times \frac{1}{2} \times \left(\frac{\pi}{6}\right)^2 + 4 \times \left(\frac{\pi}{6}\right)^2 = \frac{\pi^2}{6} \\
&amp;&amp; \square
\end{aligned}
\]</span></p>
<h3 id="algebraic-perspective">Algebraic Perspective</h3>
<p>From Taylor's series, we know that:</p>
<p><span class="math display">\[
\sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \dots
\]</span></p>
<p>Let:</p>
<p><span class="math display">\[
f(x) = \frac{\sin(x)}{x} = 1 - \frac{x^2}{3!} + \frac{x^4}{5!} - \dots
\]</span></p>
<p>Obviously the roots of <span class="math inline">\(f(x)\)</span> are <span class="math inline">\(n\pi, n \in \mathbb{Z} \backslash \{0\}\)</span>, hence:</p>
<p><span class="math display">\[
f(x) = (1 - \frac{x}{\pi})(1 + \frac{x}{\pi})(1 - \frac{x}{2\pi})(1 + \frac{x}{2\pi})\dots
\]</span></p>
<p>Consider the coeficient of <span class="math inline">\(x^2\)</span>, we have:</p>
<p><span class="math display">\[
-\left(\frac{1}{\pi^2} + \frac{1}{(2\pi)^2} + \frac{1}{(3\pi)^2} + \dots\right) = -\frac{1}{3!}
\]</span></p>
<p>Which also shows that:</p>
<p><span class="math display">\[
\sum_{n=1}^{\infty} \frac{1}{n^2} = \frac{\pi^2}{6}
\]</span></p>
<h3 id="application">Application</h3>
<blockquote>
<p>What's the probability that any two arbitrary positive integers are <strong>relatively prime</strong>?</p>
</blockquote>
<p>For any prime <span class="math inline">\(p\)</span>，those integers won't be <strong>relatively prime</strong> if they are both multiples of <span class="math inline">\(p\)</span>, thus the probability is:</p>
<p><span class="math display">\[
\begin{aligned}
P &amp;= \prod_{p\, \mathrm{is\ prime}} \left(1 - \frac{1}{p^2}\right) \\
&amp;= \prod_{p\, \mathrm{is\ prime}} \cfrac{1}{\displaystyle \sum_{i=0}^{\infty} \left(\cfrac{1}{p^2}\right)^i} \\
&amp;= \frac{1}{\displaystyle \sum_{i=1}^{\infty} \frac{1}{i^2}} \\
&amp;= \frac{6}{\pi^2}
\end{aligned}
\]</span></p>
]]></content>
      <tags>
        <tag>Combinatorial</tag>
        <tag>Induction</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展埃氏筛法小结</title>
    <url>/2018/ex-eratos-sieve/</url>
    <content><![CDATA[<p>学完洲阁筛之后忘得差不多了, 不过现在已经可以将洲阁筛扔进垃圾桶了...</p>
<a id="more"></a>
<h3 id="description">Description</h3>
<p>求:</p>
<p><span class="math display">\[h(n) = \sum_{i=1}^{n} f(i)\]</span></p>
<p>其中 <span class="math inline">\(f\)</span> 是定义在正整数集下的积性函数, 满足 <span class="math inline">\(f(p^c)\)</span> 能够快速计算.</p>
<h3 id="conversion">Conversion</h3>
<p>首先可以将所有要求的数按照是否只含大于 <span class="math inline">\(\sqrt{n}\)</span> 的质因子分为两类, 对于第一类数一定是一个质数, 而第二类数一定可以在某个较小的质因子处考虑到, 于是我们只关注不超过 <span class="math inline">\(\sqrt{n}\)</span> 的那些质因子.</p>
<p>定义 <span class="math inline">\(S_k(n, i)\)</span> 表示小于等于 <span class="math inline">\(n\)</span> 的数中与前 <span class="math inline">\(i\)</span> 个质数互质的所有数与<strong>所有质数</strong>的 <span class="math inline">\(k\)</span> 次方和, 容易得到转移:</p>
<p><span class="math display">\[
S_k(n, i) = 
\begin{cases}
S_k(n, i-1) &amp; n &lt; p_i^2 \\
S_k(n, i-1) - p_i^k \times \left(S_k(\left \lfloor \frac{n}{p_i} \right \rfloor, i - 1) - S_k(p_{i-1}, i - 1)\right) &amp; \mathrm{otherwise} 
\end{cases}
\]</span></p>
<p>在考虑完 <span class="math inline">\(\sqrt{n}\)</span> 以内的所有质因数后, <span class="math inline">\(S_k(n)\)</span> 中留下了所有质数的 <span class="math inline">\(k\)</span> 次方, 这样所有第一类数的函数值都可以快速计算.</p>
<p>类似地, 定义 <span class="math inline">\(G(n, i)\)</span> 表示小于等于 <span class="math inline">\(n\)</span> 的数中仅由第 <span class="math inline">\(i\)</span> 个以后的质数构成的数与<strong>所有质数</strong> <span class="math inline">\(x\)</span> 的 <span class="math inline">\(f(x)\)</span> 之和, 转移的方式类似:</p>
<p><span class="math display">\[
G(n, i) = G(n, i+1) + \sum_{c=0}^{\substack{p_i^{c+1} \le n}} f(p_i^{c+1}) + f(p_i^c) \times \left(G(\left \lfloor \frac{n}{p_i^c} \right \rfloor, i+1) - G(p_i, i+1)\right)
\]</span></p>
<p>复杂度约为 <span class="math inline">\(O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)\)</span></p>
<h3 id="code">Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SIV &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    uint val[M + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> prime[M + <span class="number">5</span>], pcnt;</span><br><span class="line">    uint s[M + <span class="number">5</span>], S[M + <span class="number">5</span>];</span><br><span class="line">    uint f[M + <span class="number">5</span>], F[M + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> uint <span class="title">gets</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= m ? s[x] : S[n / x]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> uint <span class="title">getf</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= m ? f[x] : F[n / x]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">my_sqrt</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1l</span>l * (r + <span class="number">1</span>) * (r + <span class="number">1</span>) &lt;= x) ++ r;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _n)</span> </span>&#123;</span><br><span class="line">        m = my_sqrt(n = _n);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            val[i] = <span class="number">81</span> * i * i - <span class="number">27</span> * i + <span class="number">9</span>;</span><br><span class="line">            s[i] = i - <span class="number">1</span>;</span><br><span class="line">            S[i] = (n / i) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= m; ++p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[p] == s[p<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            prime[pcnt ++] = p;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">const</span> uint _s = s[p - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> ll q = <span class="number">1l</span>l * p * p, lim = min((ll) m, n / q), x = m / p, y = n / p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) S[i] -= S[i * p] - _s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= lim; ++i) S[i] -= s[y / i] - _s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= q; --i) s[i] -= s[i / p] - _s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            f[i] = s[i] * <span class="number">63</span>;</span><br><span class="line">            F[i] = S[i] * <span class="number">63</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e = pcnt; e &gt;= <span class="number">1</span>; --e) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = prime[e<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">const</span> ll q = <span class="number">1l</span>l * p * p, lim = min((ll) m, n / q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++i) &#123;</span><br><span class="line">                ll cur = n / i;</span><br><span class="line">                <span class="keyword">for</span>(ll t = p, c = <span class="number">1</span>; t * p &lt;= cur; t *= p, ++ c) &#123;</span><br><span class="line">                    F[i] += (getf(cur / t) - e * <span class="number">63</span>) * val[c] + val[c + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= q; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t = p, c = <span class="number">1</span>; t &lt;= cur / p; t *= p, ++ c) &#123;</span><br><span class="line">                    f[i] += (getf(cur / t) - e * <span class="number">63</span>) * val[c] + val[c + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>记NOI2018</title>
    <url>/2018/noi2018/</url>
    <content><![CDATA[<p>折腾了好久终于把博客修好了, 来填一些坑.</p>
<a id="more"></a>
<h3 id="day--1">Day -1</h3>
<p>上午在家无所事事, 收了下行李, 下午就到洋湖报到去了, 然后听说笔试时间调整到了上午, 感觉有点慌整个晚上都在背笔试.</p>
<h3 id="day-0">Day 0</h3>
<p>上午考笔试, 比预料中的简单很多, 没有什么快捷键之类的坑题也没有挂分, 试机就打了一个最简单的配置就跑了.</p>
<p>下午找了一间教室自习, 不知道干什么, 晚上懒得复习什么早早地睡了, 奇怪的是居然丝毫不紧张.</p>
<h3 id="day-1">Day 1</h3>
<p>第一试, 看了看题, 觉得题意都挺好理解的, 难度也基本按照题目顺序.</p>
<p>就直接开始写T1了, 写完 <span class="math inline">\(\log^2\)</span> 过了大样例直接丢到一边了, 然后看T2, 推了一个看起来有理有据的结论, 但不是很会算答案搞了很久大样例四个全错, 想了一下随便打了个特判过了其中两个, 又改了一下特判才在考试一半时间的时候过了大样例.</p>
<p>期间去上了一个厕所, 用掉20min...</p>
<p>看T3惊喜地发现68分特别傻逼, 飞快地码完过了大样例还有一个半小时, 正准备回去继续做T2最后20分的时候发现T1可能跑不过, 卡了很久的常, 期间竟然检查出好多致命的错误, 然后心里特别虚地不停检查, T2也没有继续想了.</p>
<p>好在最后并没有挂分.</p>
<h3 id="day-1.5">Day 1.5</h3>
<p>鸽了社会活动, 在自习室搞了一天颓.</p>
<p>直接打出了防沉迷警告...</p>
<h3 id="day-2">Day 2</h3>
<p>看完题目一直在想哪道题最简单, 然后T1补充了一个条件...</p>
<p>用了两个小时都没有从T1的倒数第二步推出最后一步, 想想当时可能真的受到了降智打击, 还自信地觉得T2比较可做, 码了很久发现是假算法, 感觉很慌滚去写T3暴力, 回来想先写T2的45分又不想放弃T1, 最后连T2的45分都没拿到...</p>
<p>感觉心态真的崩的厉害, 虽然最后查分发现意外的多了5分(大雾).</p>
<h3 id="总结">总结</h3>
<p>好像从去年NOIP以来, 身上一直有某种二试Debuff存在, 可能经常性的因为第一试考得不错, 而对多数情况下更难的二试心存轻视, 也没能调整好自己的心态吧.</p>
<p>不管怎样, 接下来的OI生涯, 要更加珍惜!</p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>一些碎笔</title>
    <url>/2020/pieces-of-memories/</url>
    <content><![CDATA[<h3 id="引">引</h3>
<hr>
<p>不出所料的话，48小时后，园子里的我再次回忆起这段特殊经历时，能说的就仅仅是一句“却道天凉好个秋”了。</p>
<p>但我还是决心提笔记录此时此刻的强烈感受，姑且当作为了离别而进行的某种仪式。</p>
<a id="more"></a>
<h3 id="夏日">夏日</h3>
<hr>
<p>7月底的某个午后，在炙烤的烈日下和单调的蝉声里，我补完了《EVA》的TV版和旧剧场版，随后默默将新剧版移出列表。 就像剧中真嗣拒绝了最后的补完一样，我也拒绝了对新剧版的“补完”。已经曲终人散的故事不需要重新来过，就让那绕梁的余音再多停留一会儿吧。</p>
<p>后来不知道在什么地方看到了贺炜说的话 “...我想真正的成熟应该并不是追求完美，而是直面自己的缺憾，这才是生活的本质。罗曼罗兰说过的，这个世上只有一种真正的英雄主义，那就是认清生活的真相，并且仍然热爱他...”， 倏忽间许多剧中的隐喻的迷雾也消散了。</p>
<p>于是夏日就在这蝉鸣之间不觉过去了。</p>
<h3 id="逃离">逃离</h3>
<hr>
<p>逃离城市的热闹与喧嚣的方式或许很多，但对我而言最直接的方式就是从空间上真正远离。</p>
<p>过去的一轮冬春夏秋里，都有在老宅的度过的时光：在无名芬芳里，我曾沿着历史的长河逆流而上，在那蜿蜒曲折、川流不息的轨迹里寻觅熟悉的踪迹； 也曾在点点星光下抬头仰望，敬畏着遥远时空外的浩瀚无垠；或是深入微风下浪一般涌动的稻田，透过层叠的稻叶一窥虫儿的世界。</p>
<p>窗外鸟儿的低语打断我的思绪，似乎也预示着逃离的结束，钢筋水泥的丛林里可没有这样的故事。</p>
<h3 id="城游">城游</h3>
<hr>
<p>粗略一算，这段特殊的时间，跨度之长，已接近过去好多年的总和。</p>
<p>重新踏上新街旧巷，像是久别重逢的老友。沿着7年前的方向，恍惚间，我填平时间沟壑的妄想似乎也得以暂时成立。</p>
<p>路过一个又一个熟悉的街口，整理脑中已经陌生的记忆，将他们对应在一起。就像是将思绪的碎片以现实的坐标拼接起来，重新得到记忆的地图。</p>
<p>于是沿着这地图的指示，我再次窥见过去的自己。</p>
<h3 id="梧桐雨">梧桐雨</h3>
<hr>
<p>秋雨里的法国梧桐，总莫名让我想起“梧桐更兼细雨”的意境来，虽说法国梧桐并不是梧桐，气氛也没有那么凄冷。</p>
<p>想起高中门前那条种满法桐的路了，多少个日夜朝夕，从茂密的桐荫下走过的我大概不会想到，如今的我已只能在记忆里看见当时的场景了。</p>
<p>生命中许多人，他们也就像这梧桐，在路过你生命的时候为你提供短暂的荫蔽， 而当你经过他们，他们也消失在你视野之外时，就只能留下淡漠的回忆和无力的惋惜而已。</p>
<p>写这段话的时候大概理解了几分“悲欢离合总无情”，查了一下出处是蒋捷的《虞美人·听雨》，摘录在这里作为收尾好了：</p>
<blockquote>
<p>少年听雨歌楼上，红烛昏罗帐。<br>
壮年听雨客舟中，江阔云低，断雁叫西风。<br>
而今听雨僧庐下，鬓已星星也。<br>
悲欢离合总无情，一任阶前，点滴到天明。</p>
</blockquote>
<h3 id="后记">后记</h3>
<hr>
<p>写这篇文章的时候，正好是一个旧的阶段将要过去，新的旅途尚未开始的时候，混乱的记忆和杂糅的情感不断交织，希望利用这碎笔的形式一吐心中积郁。 然而实在太久没有写点什么的尝试了，我浅薄的笔力已经无法驾驭乱飘的思绪，只好任其裹挟，零落不已。 而这样吐露式的尝试并不能将复杂的心绪重新梳理，于是有这段后记。</p>
<p>以当下的状态回望彼时的心境，感到积郁的缘由无非以下种种：在寒假开始之前，犯了一些错误，也相应的付出了一些代价； 加上疫情期间隔离在家的某种压抑感，让情绪在心中积累、发酵；好不容易调整之后突然又到了分别之时...</p>
<p>细细梳理下来，发现也没有多么难以面对，无非是这些东西缠在一起，像一团乱麻让人无从下手。而当它们被抽丝剥茧一样样梳理出来时，我好像也变得释然了。</p>
<p>整个的这段特殊时期，就像是一次长假，仿佛无形的手按下了暂停，于是不顺心的事情全部抛诸脑后，停下来，休息调整。 幸运的是，尽管经历诸多波折，在这个假期里还是遇到了许多对我意义重大的人和事，与我共同面对，共同克服，我也总算在长假的尾声中重整了自己的心绪。 至于现在，无形的手又一次按下播放，我将重新开始着眼未来，面对前方未知的道路。过去的情绪就让它们留在过去的时空吧，轻装上阵的我多带任何一点都会成为累赘的。</p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Cryptography Notes</title>
    <url>/2020/cryptography/</url>
    <content><![CDATA[<p>Some notes of 🔒 cryptography lessons</p>
<p><strong>TODO</strong>:</p>
<ul>
<li><input type="checkbox" disabled checked>
Reconstruct the architecture of this post</li>
<li>Complete other contents
<ul class="task-list">
<li><input type="checkbox" disabled checked>
I: Pseudorandomness</li>
<li><input type="checkbox" disabled checked>
II: Cipher</li>
<li><input type="checkbox" disabled>
III: MAC</li>
<li><input type="checkbox" disabled>
IV: Attack &amp; Security</li>
<li><input type="checkbox" disabled>
V: Public-key Cryptography</li>
</ul></li>
</ul>
<a id="more"></a>
<h1 id="preliminary-fundamental-discrete-probability"><em>Preliminary: Fundamental Discrete Probability</em></h1>
<p>Suppose <span class="math inline">\(U\)</span> is a finite set.</p>
<h2 id="probability-distribution"><em>Probability Distribution</em></h2>
<blockquote>
<p>a <code>probability distribution</code> <span class="math inline">\(P\)</span> over <span class="math inline">\(U\)</span> is a function <span class="math display">\[P: U \rightarrow [0,1]\]</span> s.t. <span class="math display">\[\sum_{x \in U} P(x) = 1\]</span></p>
</blockquote>
<p>Some examples:</p>
<ul>
<li>Uniform distribution: <span class="math inline">\(\forall x \in U, P(x) = \dfrac{1}{|U|}\)</span></li>
<li>Pointed distribution: <span class="math inline">\(\exists x \in U, P(x) = 1\)</span></li>
</ul>
<h2 id="event"><em>Event</em></h2>
<blockquote>
<p>an <code>event</code> is a subset <span class="math inline">\(E\)</span> of <span class="math inline">\(U\)</span>, define the probability of <span class="math inline">\(E\)</span> under <code>probability distribution</code> <span class="math inline">\(P\)</span> as below: <span class="math display">\[Pr[E] = \sum_{x \in E} P(x)\]</span></p>
</blockquote>
<h3 id="the-union-bound"><em>The Union Bound</em></h3>
<p>By definition, we can obviously get:</p>
<p><span class="math display">\[Pr[A_1 \cap A_2] + Pr[A_1 \cup A_2] = Pr[A_1] + Pr[A_2]\]</span></p>
<p>Which also implies that:</p>
<p><span class="math display">\[Pr[A_1 \cup A_2] \le Pr[A_1] + Pr[A_2]\]</span></p>
<h2 id="random-variable"><em>Random Variable</em></h2>
<blockquote>
<p>a <code>random variable</code> <span class="math inline">\(X\)</span> is a function <span class="math display">\[X:U \rightarrow V\]</span> where <span class="math inline">\(V\)</span> is <strong>range</strong> of <span class="math inline">\(X\)</span></p>
</blockquote>
<p>Example <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<p><span class="math display">\[
\begin{aligned}
X:\{0, 1\}^n \rightarrow \{0, 1\} \\
X(b) = LSB(b) \in \{0, 1\}
\end{aligned}
\]</span></p>
<p>As you can see, <code>random variable</code> <span class="math inline">\(X\)</span> can also induce <code>probability distribution</code> from <span class="math inline">\(U\)</span> to <span class="math inline">\(V\)</span> (Suppose <span class="math inline">\(P\)</span> is a distribution on <span class="math inline">\(U\)</span>):</p>
<p><span class="math display">\[
\forall v \in V, Q(v) = Pr[X = v] = Pr[X^{-1}(v)]
\]</span></p>
<h3 id="uniform-random-variable"><em>Uniform Random Variable</em></h3>
<p>Specially, when <span class="math inline">\(P\)</span> is uniform distribution and <span class="math inline">\(X(r) = r\)</span> for all <span class="math inline">\(r \in U\)</span>, then:</p>
<p><span class="math display">\[
\forall r \in U, Pr[X = r] = \frac{1}{|U|}
\]</span></p>
<p>this is called <code>uniform random variable</code>, denoted by <span class="math inline">\(X \xleftarrow{R} U\)</span></p>
<h2 id="independence"><em>Independence</em></h2>
<ul>
<li>Two <code>events</code> <span class="math inline">\(A, B\)</span> are independent <strong>iff</strong>: <span class="math inline">\(Pr[A \cap B] = Pr[A] \times Pr[B]\)</span></li>
<li>Two <code>random variables</code> <span class="math inline">\(A, B\)</span> are independent <strong>iff</strong> <span class="math inline">\(\forall a \in V_A, b \in V_B\)</span>:</li>
</ul>
<p><span class="math display">\[
Pr[A = a \,\,\mathrm{and}\,\, B = b] = Pr[A = a] \times Pr[B = b]
\]</span></p>
<blockquote>
<p>For better understanding of independence, consider the example below: Suppose a dice numbered by <span class="math inline">\(D = \{1, 2, \dots, 6\}\)</span> and 2 <code>random variables</code> <span class="math inline">\(A, B\)</span>: <span class="math display">\[ \begin{aligned}
&amp;A:D \rightarrow \{0, 1\} &amp;A(x) = [x \equiv 0 \pmod 2] \\
&amp;B:D \rightarrow \{0, 1\} &amp;B(x) = [x \equiv 0 \pmod 3] 
\end{aligned} \]</span> For uniform distribution of <span class="math inline">\(D\)</span>, <span class="math inline">\(A, B\)</span> are obviously independent. Think about conditions below:</p>
<ol type="1">
<li><span class="math inline">\(B(x) = [x \equiv 0 \pmod 4]\)</span></li>
<li><span class="math inline">\(D = \{1, 2, \dots, 5\}\)</span></li>
</ol>
</blockquote>
<h2 id="more-about-probability"><em>More about Probability</em></h2>
<p><a href="https://crypto.stanford.edu/~blynn/pr/" target="_blank" rel="noopener">See also</a></p>
<h1 id="i-pseudorandomness"><em>I: Pseudorandomness</em></h1>
<p><code>Pseudorandomness</code> measures the extent to which a sequence of numbers, though produced by a completely deterministic and repeatable process, appear to be patternless.</p>
<h2 id="pseudo-random-generator"><em>Pseudo-random Generator</em></h2>
<p>A <code>Pseudo-random Generator</code>, or <code>PRG</code> for short, is an efficient, deterministic algorithm <span class="math inline">\(G\)</span> that given as input a <code>seed</code> <span class="math inline">\(s\)</span>, computes an output <span class="math inline">\(r\)</span>. Both <span class="math inline">\(s\)</span> and <span class="math inline">\(r\)</span> come from a finite space, called <span class="math inline">\(\mathcal{S}\)</span> and <span class="math inline">\(\mathcal{R}\)</span> respectively.</p>
<p>Typically <span class="math inline">\(\mathcal{S}\)</span> and <span class="math inline">\(\mathcal{R}\)</span> are sets of bit strings of some prescribed length. We can also regard <span class="math inline">\(G\)</span> as an abstract function defined over <span class="math inline">\(\mathcal{(S, R)}\)</span>:</p>
<p><span class="math display">\[
G: \mathcal{S} = \{0, 1\}^l \rightarrow \mathcal{R} = \{0, 1\}^L
\]</span></p>
<h3 id="security"><em>Security</em></h3>
<p>We say a PRG <span class="math inline">\(G\)</span> is secure if <span class="math inline">\(G(s)\)</span> and <span class="math inline">\(r\)</span> are <strong>computational indistinguishable</strong>, among which <span class="math inline">\(s\)</span> is chosen uniform randomly from <span class="math inline">\(\mathcal{S}\)</span> and <span class="math inline">\(r\)</span> is chosen at random from <span class="math inline">\(\mathcal{R}\)</span>.</p>
<p>To illustrate <strong>computational indistinguishability</strong>, the definition is formulated as an attack game:</p>
<blockquote>
<h4 id="attack-game-prg-and-advantage"><em>Attack Game (PRG) and Advantage</em></h4>
<p>For a given PRG <span class="math inline">\(G\)</span> defined over <span class="math inline">\(\mathcal{(S, R)}\)</span>, and for a given adversary <span class="math inline">\(\mathcal{A}\)</span>, we define two experiments, Experiment <span class="math inline">\(0\)</span> and Experiment <span class="math inline">\(1\)</span>:</p>
<p><strong>Experiment</strong> <span class="math inline">\(b\)</span>:</p>
<ul>
<li><p>The Challenger computes <span class="math inline">\(r \in \mathcal{R}\)</span> as follows: <img src="/img/PRG-ADV.png" alt="PRG-ADV"></p>
<ul>
<li>if <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(s \xleftarrow{R} \mathcal{S}, r \leftarrow G(s)\)</span></li>
<li>if <span class="math inline">\(b = 1\)</span>, <span class="math inline">\(r \xleftarrow{R} \mathcal{R}\)</span></li>
</ul></li>
<li><p>Given <span class="math inline">\(r\)</span>, the adversary computes and outputs a bit <span class="math inline">\(\hat{b} \in \{0, 1\}\)</span></p></li>
</ul>
<p>For <span class="math inline">\(b \in \{0, 1\}\)</span>, let <span class="math inline">\(W_b\)</span> be the event that <span class="math inline">\(\mathcal{A}\)</span> outputs <span class="math inline">\(\hat{b} = 1\)</span> in Experiment <span class="math inline">\(b\)</span>. We define <span class="math inline">\(\mathcal{A}\)</span>'s <code>advantage</code> with respect to <span class="math inline">\(G\)</span> as</p>
<p><span class="math display">\[
PRG_{adv} [\mathcal{A}, G] = \left|Pr[W_0] - Pr[W_1]\right|
\]</span></p>
</blockquote>
<p>Now we can define a PRG <span class="math inline">\(G\)</span> is <strong>secure</strong> if the value <span class="math inline">\(PRG_{adv} [\mathcal{A}, G]\)</span> is negligible <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> for all efficient adversaries <span class="math inline">\(\mathcal{A}\)</span>.</p>
<h2 id="pseudo-random-function"><em>Pseudo-random Function</em></h2>
<p>A <code>Pseudo-random Function(PRF)</code> <span class="math inline">\(F\)</span> is a deterministic algorithm that has two inputs: a <code>key</code> <span class="math inline">\(k\)</span> and an <code>input data block</code> <span class="math inline">\(x\)</span>; its output <span class="math inline">\(y := F(k, x)\)</span> is called an <code>output data block</code>. We denote the finite space of <span class="math inline">\(k, x, y\)</span> with <span class="math inline">\((\mathcal{K, X, Y})\)</span>, over which is <span class="math inline">\(F\)</span> defined.</p>
<p>Intuitively, our notion of security says that for a randomly chosen key <span class="math inline">\(k\)</span>, <span class="math inline">\(F(k, \cdot )\)</span> is indistinguishable from a random function from <span class="math inline">\(\mathcal{X}\)</span> to <span class="math inline">\(\mathcal{Y}\)</span></p>
<blockquote>
<h3 id="notation"><strong>Notation</strong></h3>
<p><span class="math display">\[
Funs[\mathcal{X, Y}] = \{f: \mathcal{X} \rightarrow \mathcal{Y}\}
\]</span> clearly we know that <span class="math display">\[
|Funs[\mathcal{X, Y}]| = |\mathcal{Y}|^{|\mathcal{X}|}
\]</span></p>
</blockquote>
<h3 id="attack-game-prf"><em>Attack Game (PRF)</em></h3>
<p>Similarly we can define two experiments, Experiment <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, for a PRF <span class="math inline">\(F\)</span> defined over <span class="math inline">\((\mathcal{K, X, Y})\)</span>:</p>
<p><strong>Experiment</strong> <span class="math inline">\(b\)</span>:</p>
<ul>
<li>The challenger selects <span class="math inline">\(f\)</span> as follows:
<ul>
<li>if <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(k \xleftarrow{R} \mathcal{K}, f \leftarrow F(k, \cdot)\)</span></li>
<li>if <span class="math inline">\(b = 1\)</span>, <span class="math inline">\(f \xleftarrow{R} Funs[\mathcal{X, Y}]\)</span></li>
</ul></li>
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> submits a sequence of queries <span class="math inline">\(x_1, \dots, x_q\)</span>, and receives <span class="math inline">\(y_i = f(x_i)\)</span> for each <span class="math inline">\(i\)</span> from the challenger</li>
<li>The adversary computes <span class="math inline">\(\hat{b} \in \{0, 1\}\)</span></li>
</ul>
<p>Let <span class="math inline">\(W_b\)</span> be the event <span class="math inline">\(\mathcal{A}\)</span> outputs <span class="math inline">\(1\)</span> in Experiment <span class="math inline">\(b\)</span>, the <code>advantage</code> is also defined by:</p>
<p><span class="math display">\[
PRF_{adv} [\mathcal{A}, F] = |Pr[W_0] - Pr[W_1]|
\]</span></p>
<p>We say a PRF <span class="math inline">\(F\)</span> is <strong>secure</strong> if all efficient adversary <span class="math inline">\(A\)</span> have a negligible advantage.</p>
<h2 id="pseudo-random-permutation"><em>Pseudo-random Permutation</em></h2>
<p>Also called <a href="#bc">Block Cipher</a>, is a special PRF which is also invertible.</p>
<h1 id="ii-cipher"><em>II: Cipher</em></h1>
<p>Throughout history, there were many ways of encryption, however, some of them have been proved unsafe. The question now is whether a particular <code>cipher</code> is <strong>secure</strong> and how to construct a <strong>secure</strong> one.</p>
<blockquote>
<p>A <code>cipher</code> defined over a triple <span class="math inline">\((\mathcal{K, M, C})\)</span> is a pair of <strong>efficient</strong><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> algos <span class="math inline">\((E, D)\)</span> where:</p>
<p><span class="math display">\[
\begin{aligned}
E: \mathcal{K \times M} \rightarrow \mathcal{C} \\
D: \mathcal{K \times C} \rightarrow \mathcal{M}
\end{aligned}
\]</span> s.t. <span class="math inline">\(\forall m \in \mathcal{M}, k \in \mathcal{K}\)</span> <span class="math display">\[
m = D(k, E(k, m))
\]</span> and <span class="math inline">\(\mathcal{K, M, C}\)</span> denote the space of keys, messages and cipher texts.</p>
</blockquote>
<h2 id="stream-cipher"><em>Stream Cipher</em></h2>
<p>The example below shows the basic idea of stream cipher.</p>
<h3 id="otp"><em>One Time Pad</em></h3>
<p>An example cipher over <span class="math inline">\(\mathcal{K, M, C} = \{0, 1\}^n\)</span> and:</p>
<p><span class="math display">\[
\begin{aligned}
E(k, m) &amp;= k \oplus m \\
D(k, c) &amp;= k \oplus c \\
\end{aligned}
\]</span></p>
<h2 id="perfect-secrecy"><em>Perfect Secrecy</em></h2>
<p>The basic idea behind perfect secrecy is: cipher text should reveal no "info" about plain text.</p>
<blockquote>
<p>A <code>cipher</code> <span class="math inline">\((E, D)\)</span> over <span class="math inline">\(\{\mathcal{K, M, C}\}\)</span> has <code>perfect secrecy</code> <strong>iff</strong>:</p>
<p><span class="math inline">\(\forall m_0, m_1 \in \mathcal{M} \,\,\mathrm{that}\,\, |m_0| = |m_1|, c \in \mathcal{C}\)</span>: <span class="math display">\[Pr[E(k, m_0) = c] = Pr[E(k, m_1) = c]\]</span> where <span class="math inline">\(k \xleftarrow{R} \mathcal{K}\)</span></p>
</blockquote>
<p>It's not hard to see that when attacker gets a cipher text, he will have no idea what the plain text is. By definition, we can also prove <a href="#otp">One Time Pad</a> has <code>perfect secrecy</code>.</p>
<p>However, <code>perfect secrecy</code> is too hard to satisfy because we have theorem says:</p>
<blockquote>
<p>If a <code>cipher</code> has <code>perfect secrecy</code>, then: <span class="math display">\[|\mathcal{K}| \ge |\mathcal{M}|\]</span> which means the length of keys mustn't less than length of messages.</p>
</blockquote>
<p>That somehow makes no sense for if we have some way sending and receiving such long keys secretly, then it's absolutely unnecessary to use <code>cipher</code>.</p>
<h3 id="stream-cipher-in-practice"><em>Stream Cipher in Practice</em></h3>
<p>However, <code>One Time Pad</code> is not mainly used in practice because:</p>
<ol type="1">
<li>The key space <span class="math inline">\(\mathcal{K}\)</span> is as large as message space <span class="math inline">\(\mathcal{M}\)</span>, which makes no sense in communication.</li>
<li>For two same message segments in different positions, they would also be same in the cipher text.</li>
</ol>
<p>In practice, we have to change some details to solve these problems:</p>
<ol type="1">
<li><p>We can implement a <code>PRF</code> <span class="math inline">\(G\)</span> with seed space <span class="math inline">\(\mathcal{S}\)</span> much less than the message space <span class="math inline">\(\mathcal{M}\)</span>, and rewrite the process of encryption and decryption as: <span class="math display">\[
\begin{aligned}
E(k, m) &amp;= G(k) \oplus m \\
D(k, c) &amp;= G(k) \oplus c
\end{aligned}
\]</span> By the properties of <code>PRF</code> we could argue the security.</p></li>
<li><p>To solve this problem, we can change the key after a fixed length of message or using a nonce, the later one will appear in remain chapters.</p></li>
</ol>
<h2 id="bc"><em>Block Cipher</em></h2>
<p>A <code>block cipher</code> defined over <span class="math inline">\((\mathcal{K, X})\)</span> is a deterministic <span class="math inline">\((E, D)\)</span> whose message space and cipher space is same (finite) set <span class="math inline">\(\mathcal{X}\)</span>. Additionally, for each <span class="math inline">\(k \in \mathcal{K}\)</span>, it's necessary that <span class="math inline">\(E(k, \cdot)\)</span> is invertible, which also means <span class="math inline">\(f_k := E(k, \cdot)\)</span> is an one-to-one map on finite set <span class="math inline">\(\mathcal{X}\)</span> and <span class="math inline">\(D(k, \cdot) = f_k^{-1}\)</span>.</p>
<p>It's not hard to see that <span class="math inline">\(D(k, E(k, m)) = m\)</span>, so the point now is to argue the security of <code>block cipher</code> (also called <code>Pseudo-random Permutation</code>, <code>PRP</code>). Before that, let's focus on the properties of invertible function on a finite set <span class="math inline">\(\mathcal{X}\)</span>:</p>
<ol type="1">
<li><p>Some notation: <span class="math display">\[
Perm[\mathcal{X}] = \{F \in Funs[\mathcal{X, X}] : F \text{ is invertible}\}
\]</span></p></li>
<li><p>Obviously: <span class="math display">\[
|Perm[\mathcal{X}]| = |\mathcal{X}|!
\]</span></p></li>
</ol>
<h3 id="attack-game-prp-security"><em>Attack Game (PRP) &amp; Security</em></h3>
<p>Similarly with the idea used in attacking <code>PRF</code>, we design an attack game for a certain <code>block cipher</code> (or <code>PRP</code>) <span class="math inline">\(\mathcal{E} = (E, D)\)</span> over <span class="math inline">\((\mathcal{K, X})\)</span> against an attacker <span class="math inline">\(\mathcal{A}\)</span>:</p>
<p>Experiment <span class="math inline">\(b\)</span>:</p>
<ol type="1">
<li><p>Challenger selects <span class="math inline">\(f\)</span> as follow</p>
<ul>
<li>if <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(k \xleftarrow{R} \mathcal{K}, f = E(k, \cdot)\)</span></li>
<li>if <span class="math inline">\(b = 1\)</span>, <span class="math inline">\(f \xleftarrow{R} Perm[\mathcal{X}]\)</span></li>
</ul></li>
<li><p>Attacker choose a sequence of input <span class="math inline">\(x_1, x_2, \dots, x_q\)</span>, and get <span class="math inline">\(y_i = f(x_i)\)</span> from the challenger.</p></li>
<li><p>Attacker output a <span class="math inline">\(\hat{b} \in \{0, 1\}\)</span>.</p></li>
</ol>
<p>The advantage is defined as:</p>
<p><span class="math display">\[
BC_{ADV}[\mathcal{A, E}] = |Pr[W_0] - Pr[W_1]|
\]</span></p>
<p>where <span class="math inline">\(W_b\)</span> describe the event that <span class="math inline">\(\mathcal{A}\)</span> outputs <span class="math inline">\(\hat{b} = 1\)</span> in Experiment <span class="math inline">\(b\)</span>, <span class="math inline">\(\mathcal{E}\)</span> is <strong>secure</strong> if the advantage is negligible for all efficient algorithm <span class="math inline">\(\mathcal{A}\)</span>.</p>
<h3 id="practice">Practice</h3>
<p>In practice, we often divide messages into "blocks", then implement <code>block cipher</code> to them and concate to get the cipher text.</p>
<h1 id="iii-message-integrity"><em>III: Message Integrity</em></h1>
<p>In previous chapters, we mainly focused on security against an eavesdropping adversary, which could not change messages en-route. In this chapter we turn out attention to active adversaries by startting with the basic question of <em>message integrity</em>: Bob receives a message <span class="math inline">\(m\)</span> from Alice, and he wants to convince himself that the message was not modified en-route.</p>
<p>Alice could send a extra tag <span class="math inline">\(t\)</span> of message <span class="math inline">\(m\)</span> to Bob, when Bob receives the pair <span class="math inline">\((m, t)\)</span>, he can determine that by recalculating the tag of <span class="math inline">\(m\)</span> and then checking whether it is <span class="math inline">\(t\)</span>.</p>
<h2 id="message-authentication-code-mac"><em>Message Authentication Code (MAC)</em></h2>
<p>A <code>MAC</code> system <span class="math inline">\(\mathcal{I} = (S,V)\)</span> is a pair of efficient algorithms, <span class="math inline">\(S\)</span> and <span class="math inline">\(V\)</span>, where <span class="math inline">\(S\)</span> is called a <code>signing algorithm</code> and <span class="math inline">\(V\)</span> is called a <code>verification algorithm</code>. <span class="math inline">\(S\)</span> is used to generate tags and <span class="math inline">\(V\)</span> is to verify tags.</p>
<ul>
<li><span class="math inline">\(S\)</span> is a probabilistic algorithm that is invoked as <span class="math inline">\(t \xleftarrow{R} S(k, m)\)</span>, where <span class="math inline">\(k\)</span> is a key, <span class="math inline">\(m\)</span> is a message.</li>
<li><span class="math inline">\(V\)</span> is a deterministic algorithm that is invoked as <span class="math inline">\(r = V(k, m, t)\)</span>, where <span class="math inline">\(k\)</span> is a key, <span class="math inline">\(m\)</span> is a message, <span class="math inline">\(t\)</span> is a tag, and <span class="math inline">\(r \in \{0, 1\}\)</span></li>
<li>For all keys and all messages:</li>
</ul>
<p><span class="math display">\[
V(k, m, S(k, m)) = 1
\]</span></p>
<p>As usual, we say that keys, messages and tags lie in some finite key space <span class="math inline">\(\mathcal{K, M, T}\)</span>. We say that <span class="math inline">\(\mathcal{I} = (S, V)\)</span> is defined over <span class="math inline">\(\mathcal{K, M, T}\)</span>.</p>
<h2 id="security-of-macs"><em>Security of MACs</em></h2>
<p>Suppose an adversary is attacking a MAC system <span class="math inline">\(\mathcal{I} = (S, V)\)</span>. Let <span class="math inline">\(k\)</span> be some randomly chosen MAC key, which is unknown to the attacker. We allow the attacker to request tags <span class="math inline">\(t := S(k, m)\)</span> for arbitrary messages <span class="math inline">\(m\)</span> of its choice. And the attacker need to come up with a <em>new</em> pair <span class="math inline">\((m, t)\)</span> satisfies <span class="math inline">\(V(k, m, t) = 1\)</span>.</p>
<h1 id="iv-attack-security"><em>IV: Attack &amp; Security</em></h1>
<h1 id="v-public-key-cryptography"><em>V: Public-key Cryptography</em></h1>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>LSB is a function which gets the last significant bit of a bit-string.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Negligible means small enough so that cannot be detected even by enormous samples.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Theoretically, efficient means runs in polynomial time; Practically it means runs within a certain time period.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <tags>
        <tag>Probability</tag>
        <tag>Induction</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>互测题总结</title>
    <url>/2018/problem-select/</url>
    <content><![CDATA[<h3 id="string">String</h3>
<h4 id="description">Description</h4>
<blockquote>
<p>称一个仅由<code>a</code>, <code>b</code>, <code>c</code>组成的字符串 <span class="math inline">\(S\)</span> 是平衡的当且仅当对于 <span class="math inline">\(S\)</span> 的任意一个连续子串 <span class="math inline">\(T\)</span>, 任意两种字符的出现次数之差都小于等于 <span class="math inline">\(k\)</span>, 求长度为 <span class="math inline">\(n\)</span> 的平衡串的数量.</p>
</blockquote>
<p><span class="math inline">\(n \le 10^9, K \le 8\)</span></p>
<a id="more"></a>
<h4 id="solution">Solution</h4>
<p>定义 <span class="math inline">\(f_{a, b}(i)\)</span> 表示在前 <span class="math inline">\(i\)</span> 个字符中 <code>a</code> 和 <code>b</code> 出现次数之差, 在只考虑 <code>a</code>, <code>b</code> 两种字符的条件等价于:</p>
<p><span class="math display">\[\max_{i=1}^{n} f_{a, b}(i) - \min_{i=1}^{n} f_{a, b}(i) \le k\]</span></p>
<p>注意到如果 <span class="math inline">\(f_{a, b}\)</span> 的值域区间长度为 <span class="math inline">\(len\)</span>, 则被所有长度为 <span class="math inline">\(k\)</span> 的值域区间计算的次数是 <span class="math inline">\(k - len + 1\)</span>. 记 <span class="math inline">\(g(x, y, z)\)</span> 表示三种 <span class="math inline">\(f\)</span> 的值域区间长度限制分别为 <span class="math inline">\(x, y, z\)</span> 时的方案数, 那么可以容斥计算答案:</p>
<p><span class="math display">\[ans = g(k, k, k) - 3 g(k, k, k-1) + 3 g(k, k-1, k-1) - g(k-1, k-1, k-1)\]</span></p>
<p>考虑如何计算 <span class="math inline">\(g(x, y, z)\)</span>, 以 <span class="math inline">\(x\)</span> 为例, 每一个合法的区间一定可以表示成 <span class="math inline">\(s_x + l_x \mid l_x \in [0, x]\)</span> 的形式.</p>
<p>因为初始状态的 <span class="math inline">\(l\)</span> 确定了 <span class="math inline">\(s\)</span> , 接下来的转移只需要保证 <span class="math inline">\(l\)</span> 的范围即可, 由于:</p>
<p><span class="math display">\[f_{a, b}(i) - f_{a, c}(i) = f_{c, b}(i)\]</span></p>
<p>考虑对于 <span class="math inline">\(z\)</span> 的限制, 有:</p>
<p><span class="math display">\[s_z + s_y - s_x \le l_x - l_y \le s_z + s_y - s_x + l_z\]</span></p>
<p>每次转移之前枚举一下 <span class="math inline">\(s_z + s_y - s_x\)</span> 即可, 这样状态只需要考虑 <span class="math inline">\(l_x, l_y\)</span> 即可, 并且初始状态唯一确定 <span class="math inline">\(s_x, s_y, s_z\)</span>.</p>
<h3 id="sequence">Sequence</h3>
<h4 id="description-1">Description</h4>
<blockquote>
<p>对长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a_i\}\)</span>, 定义 <span class="math inline">\(sum(l, r)\)</span> 为第 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 项的元素之和, <span class="math inline">\(inc(l, r)\)</span> 为第 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 项的非空上升子序列的最大权值和, 求 <span class="math inline">\(\max_{1 \le l,\, r \le n} sum(l, r) - inc(l, r)\)</span>, 以及同时满足区间长度最小的 <span class="math inline">\((l, r)\)</span> 的数量.</p>
</blockquote>
<p><span class="math inline">\(n \le 2 \times 10^5, |a_i| \le 40\)</span></p>
<h4 id="solution-1">Solution</h4>
<p>由于权值的范围比较小, <span class="math inline">\(inc\)</span> 的范围也不大, 同时一定存在方案使得 <span class="math inline">\(inc\)</span> 中只包含正数.</p>
<p>考虑从左到右枚举右端点, 由于最小化区间长度的需要, 记录 <span class="math inline">\(dp(i, j)\)</span> 表示右边界不超过当前枚举的位置, 最长上升子序列的权值和为 <span class="math inline">\(i\)</span> 且最后一位的权值为 <span class="math inline">\(j\)</span> 时最靠右的左端点的位置. 转移可以做到 <span class="math inline">\(O(n |a_i|^3)\)</span></p>
<p>接下来考虑计算答案, 从大到小枚举 <span class="math inline">\(inc\)</span> 可能的值, 并求其最靠右的左端点如果左端点是单调增的则说明选择中间这部分的左端点 <span class="math inline">\(inc\)</span> 会发生变化, 找一个能最优化 <span class="math inline">\(sum\)</span> 的同时区间长度最小的左端点即可.</p>
<h3 id="game">Game</h3>
<h4 id="description-2">Description</h4>
<blockquote>
<p><span class="math inline">\(n\)</span> 个人在一起玩游戏每个人初始有一张牌, 牌上的数字构成一个 <span class="math inline">\(1-n\)</span> 的排列, 所有人从左到右进行决策: 翻开自己的牌并留在原地, 或者选一个之前的人与其交换手中的牌并离开游戏, 之前的人将他的牌翻开. 每个人都会采取最佳策略, 并希望自己手中的牌上的数字尽可能大. 定义 <span class="math inline">\(E(n)\)</span> 为 <span class="math inline">\(n\)</span> 个人进行游戏最后留在原地的人的数量的期望.</p>
</blockquote>
<p><span class="math display">\[
\begin{aligned}
S_k(n) = 
\begin{cases}
    E(n)  &amp; \text{k = 0} \\
    \sum_{i=1}^{n} S_{k-1}(i) &amp; \text{otherwise} \\
\end{cases}
\end{aligned}
\]</span></p>
<p>求 <span class="math inline">\(S_k(n)\)</span>, 保留 <span class="math inline">\(10\)</span> 位有效数字.</p>
<p><span class="math inline">\(k \le 50, n \le 10^{15}\)</span></p>
<h4 id="solution-2">Solution</h4>
<p>首先需要分析每个人的策略, 已知的信息有两部分, 留在原地的人手中的数字集合<span class="math inline">\(P\)</span>, 没有进行决策的人手中的数字集合<span class="math inline">\(R\)</span>. 考虑证明最优策略下发生交换当且仅当 <span class="math inline">\(\min\{R\} &lt; \max\{P\}\)</span>.</p>
<p>不妨使用数学归纳法证明, 对于最后一个做决策的人, 决策正确性显然, 考虑剩下的人:</p>
<ul>
<li><p>当 <span class="math inline">\(\min\{R\} &gt; \max\{P\}\)</span> 时, 显然翻开手中的牌无论如何都不会再劣于 <span class="math inline">\(\max\{P\}\)</span>.</p></li>
<li><p>当 <span class="math inline">\(\min\{R\} &lt; \max\{P\}\)</span> 时, 考虑反证翻开当前的牌不会比 <span class="math inline">\(\max\{P\}\)</span> 更优:</p>
<ul>
<li>如果翻开的牌优于 <span class="math inline">\(\max\{P\}\)</span>, 由于在这之前有 <span class="math inline">\(\min\{R\} &lt; \max\{P\}\)</span>, 在最小值被翻出之前接下来的人都会选择与最大的位置交换, 如果最大值所在的位置没有发生变化这个位置最后会变成 <span class="math inline">\(\min\{R\}\)</span> 且不会有人再和他交换手中的牌, 否则这个位置需要先变得小于原本的 <span class="math inline">\(\max\{P\}\)</span>.</li>
<li>如果翻开的牌劣于 <span class="math inline">\(\max\{P\}\)</span> 则类似上述情况中先变得小于原本 <span class="math inline">\(\max\{P\}\)</span> 的情况, 每一个完整过程中要么 <span class="math inline">\(\max\{P\}\)</span> 变成 <span class="math inline">\(\min\{R\}\)</span>, 要么 <span class="math inline">\(\max\{P\}\)</span> 的位置发生变化, 最终一定都会劣于最初的 <span class="math inline">\(\max\{P\}\)</span>.</li>
</ul></li>
</ul>
<p>接下来考虑 <span class="math inline">\(E(n)\)</span>, 第 <span class="math inline">\(i\)</span> 个人选择留在原地当且仅当第 <span class="math inline">\(i-1\)</span> 个人手中的牌恰好是后缀最小值, 于是:</p>
<p><span class="math display">\[E(n) = \sum_{i=1}^{n} \frac{1}{i}\]</span></p>
<p>考虑生成函数:</p>
<p><span class="math display">\[
\begin{aligned}
F(x) &amp;= \sum_{i=1}^{\infty} \frac{1}{i} x^i \\
     &amp;= \int \frac{1}{1 - x} \\
     &amp;= -\ln(1 - x) \\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
E(x) &amp;= \frac{F(x)}{1 - x} \\
     &amp;= \frac{-\ln(1 - x)}{1 - x}
\end{aligned}
\]</span></p>
<p>接下来计算 <span class="math inline">\(S_k(n)\)</span>:</p>
<p><span class="math display">\[ 
\begin{aligned}
S_k(x) &amp;= \frac{S_{k-1}(x)}{1 - x} \\
       &amp;= \frac{-\ln(1 - x)}{(1 - x)^{k + 1}} \\
S_k&#39;(x) &amp;= \frac{(-\ln(1-x))&#39;}{(1-x)^{k + 1}} - \ln(1 - x) \left( \frac{1}{(1 - x)^{k+1}} \right)&#39; \\
        &amp;= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \left( -\frac{1}{(1 - x)^{2k + 2}} ((1-x)^{k+1})&#39; \right) \\
        &amp;= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \frac{(k + 1) (1 - x)^k}{(1 - x)^{2k+2}} \\
        &amp;= \frac{1}{(1 - x)^{k + 2}} + (k + 1) S_{k+1}(x)
\end{aligned}
\]</span></p>
<p>考虑 <span class="math inline">\(x^n\)</span> 项的系数:</p>
<p><span class="math display">\[(n+1)S_k(n+1)x^n = {n + k + 2 \choose k + 1}x^n + (k + 1) S_{k + 1}(n) x^n\]</span></p>
<p><span class="math display">\[S_{k+1}(n) = \frac{(n+1)S_k(n+1) - {n + k + 2 \choose k + 1}}{k + 1}\]</span></p>
<p>对于 <span class="math inline">\(S_0(n)\)</span>, 使用调和级数的近似公式计算, 否则递归即可.</p>
<h3 id="power">Power</h3>
<h4 id="description-3">Description</h4>
<blockquote>
<p><span class="math inline">\(n\)</span> 个连续随机变量, 第 <span class="math inline">\(i\)</span> 个变量 <span class="math inline">\(x_i\)</span> 在 <span class="math inline">\([l_i, r_i]\)</span> 中均匀随机, 求 <span class="math inline">\(\max\{ (\sum{x_i})^m, a^m \}\)</span> 的期望值对 <span class="math inline">\(998244353\)</span> 取模的结果.</p>
</blockquote>
<p><span class="math inline">\(n \le 15, m \le 10^8, |a|, |l_i|, |r_i| \le 10^6\)</span></p>
<h4 id="solution-3">Solution</h4>
<p>连续概率实际上是合法的点集在 <span class="math inline">\(n\)</span> 维超立方体中的体积占比, 点集内部用积分计算期望即可. 对于 <span class="math inline">\([0, \infty)\)</span> 范围内的 <span class="math inline">\(n\)</span> 个连续随机变量 <span class="math inline">\(\{x_i\}\)</span>, 不难归纳得到满足 <span class="math inline">\(\sum x_i \le x\)</span> 的点构成的 <span class="math inline">\(n\)</span> 维超几何体在 <span class="math inline">\(n\)</span> 维空间中的体积是 <span class="math inline">\(\frac{x^n}{n!}\)</span>.</p>
<p>考虑 <span class="math inline">\(\sum{x_i}\)</span> 和 <span class="math inline">\(a\)</span> 的大小关系.</p>
<ul>
<li><span class="math inline">\(m\)</span> 为奇数时, 需要考虑两个区间, <span class="math inline">\([-\infty, a], [a, \infty]\)</span>.</li>
<li><span class="math inline">\(m\)</span> 为偶数时, 需要计算三个区间的答案, <span class="math inline">\([-\infty, -a], [-a, a], [a, \infty]\)</span>.</li>
</ul>
<p>那么要计算在每个区间内部的期望值, 考虑将每个 <span class="math inline">\(x_i\)</span> 表示为 <span class="math inline">\(l_i + y_i\)</span> 或 <span class="math inline">\(r_i + y_i\)</span>, <span class="math inline">\(2^n\)</span> 枚举所有不合法的变量集合进行容斥, 对于 <span class="math inline">\(\sum y_i \le K\)</span> 的限制可以转化成计算:</p>
<p><span class="math display">\[\int_{0}^{K} \frac{x^{n-1}}{(n-1)!} g(x) \mathrm{d}x\]</span></p>
<p><span class="math inline">\(g(x)\)</span> 表示当 <span class="math inline">\(\sum y_i = x\)</span> 时的答案, 同一个区间内的形式是相同的.</p>
<p>对于 <span class="math inline">\(\sum y_i \ge K\)</span> 的限制可以反过来将每个 <span class="math inline">\(x_i\)</span> 表示为 <span class="math inline">\(r_i - y_i\)</span> 或者 <span class="math inline">\(l_i - y_i\)</span>, 限制 <span class="math inline">\(-\sum y_i \ge K\)</span> 可以转化为 <span class="math inline">\(\sum y_i \le K\)</span> 的形式.</p>
<h3 id="bizi">Bizi</h3>
<h4 id="description-4">Description</h4>
<blockquote>
<p>给出两棵有根树, 大小分别是 <span class="math inline">\(n_1, n_2\)</span>, 可以进行三种操作: 1. 修改: 将一条边的边权从 <span class="math inline">\(x\)</span> 改为 <span class="math inline">\(y\)</span> , 代价为 <span class="math inline">\(|x - y| \times c1\)</span>. 2. 收缩: 选择一个点, 将它的所有子树连向他的父亲, 代价为这个点到父亲的边权 <span class="math inline">\(w \times c2\)</span>. 3. 生长: 选择任意一个点的一段连续的子树, 插入一个新点连向选择的点并成为这些子树的父亲, 代价为连向原来的点的边权 <span class="math inline">\(w \times c2\)</span>.</p>
</blockquote>
<blockquote>
<p>求出使得两颗树括号序列和边权相同需要的最小代价.</p>
</blockquote>
<p><span class="math inline">\(n1 \le 50,\, n2 \le 2000\)</span></p>
<h4 id="solution-4">Solution</h4>
<p>首先不难发现操作一和操作二互为逆操作, 所以可以只考虑操作二.</p>
<p>定义 <span class="math inline">\(dp(a, b, c, d)\)</span> 表示第一颗树中 <span class="math inline">\([a, b]\)</span> 表示的括号序列区间和第二棵树中 <span class="math inline">\([c, d]\)</span> 表示的括号序列区间变得相同需要的最小代价, 考虑左端点对应的括号在最终情况下的匹配情况进行转移:</p>
<p><span class="math display">\[
dp(a, b, c, d) = \min \begin{cases} 
dp(a + 1, b, c, d) + w_{a} \times c2 \\
dp(a, b, c + 1, d) + w_{c} \times c2 \\
dp(a + 1, p_{a} - 1, b + 1, p_{b} - 1) + dp(p_{a} + 1, b, p_{c} + 1, d) + |w_{a} - w_{b}| \times c1
\end{cases}
\]</span></p>
<p><span class="math inline">\(p_x\)</span> 表示第 <span class="math inline">\(x\)</span> 个括号的匹配括号的位置, <span class="math inline">\(w_x\)</span> 表示第 <span class="math inline">\(x\)</span> 个括号和其父亲结点之间连边的边权.</p>
<p>看起来状态数是 <span class="math inline">\(O(n1^2n2^2)\)</span> 的, 实际上分析后发现有用的状态数只有 <span class="math inline">\(O(n1^2n2\log{n2})\)</span>: 因为考虑左端点进行转移和考虑右端点进行转移是等价的, 但是如果每次都选择第二棵树中子树大小较小的一侧进行转移, 关于第二棵树的状态数就是轻儿子的子树大小之和, 而这个值是不会超过 <span class="math inline">\(O(n2 \log{n2})\)</span> 的.</p>
<h3 id="circle">Circle</h3>
<h4 id="description-5">Description</h4>
<blockquote>
<p>平面上有 <span class="math inline">\(n\)</span> 个点, 求有多少个无序三元组 <span class="math inline">\((i, j, k)\)</span> 满足点 <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, <span class="math inline">\(k\)</span> 确定的圆经过坐标原点.</p>
</blockquote>
<p><span class="math inline">\(n \le 2000\)</span></p>
<h4 id="solution-5">Solution</h4>
<p>西姆松定理:</p>
<blockquote>
<p>三个点确定的圆上任选一点向这三个点构成的三角形三边所在直线分别作垂线, 垂足三点共线.</p>
</blockquote>
<p>证明可参考下图:</p>
<p><img src="/img/simson.png"></p>
<p>于是问题转化为求三点共线的数量.</p>
<h3 id="triangle">Triangle</h3>
<h4 id="description-6">Description</h4>
<blockquote>
<p>有一棵 <span class="math inline">\(n\)</span> 个点的树, 初始时树上没有石子, 可以进行若干次如下操作: 1. 如果点 <span class="math inline">\(u\)</span> 的所有子树 <span class="math inline">\(v\)</span> 上都恰好有 <span class="math inline">\(w_v\)</span> 颗石子, 则可以从手中拿出 <span class="math inline">\(w_u\)</span> 颗石子放在点 <span class="math inline">\(u\)</span> 上. 2. 将某个结点上的所有石子收回手中.</p>
<p>现在询问你对于每一个点 <span class="math inline">\(i\)</span>, 要使得 <span class="math inline">\(i\)</span> 上恰好放有 <span class="math inline">\(w_i\)</span> 颗石子, 初始时手中至少需要多少颗石子.</p>
</blockquote>
<p><span class="math inline">\(n \le 10^5, w_i \le 10^9\)</span></p>
<h4 id="solution-6">Solution</h4>
<p>首先可以发现操作的过程类似一个拓扑排序, 填上一个结点的石子之前先要将它的所有儿子都填上石子, 接着会立即收回儿子结点上的石子.</p>
<p>不妨反过来考虑, 定义一次操作为选择一个放有石子的点, 将它的儿子结点全部放上石子, 然后收回这个点的石子. 由于只需要考虑操作过程中石子数量的最大值, 可以发现反转顺序并不会影响答案.</p>
<p>用一个二元组 <span class="math inline">\((a, b)\)</span> 描述一次操作, <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> 分别表示在操作的过程中石子的总变化量和变化最大值, 注意到两个操作可以方便地合并:</p>
<p><span class="math display">\[
(a, b) + (c, d) = (a + c, \max\{b, a + d\})
\]</span></p>
<p>接下来考虑二元组 <span class="math inline">\(X = (a, b)\)</span> 和 <span class="math inline">\(Y = (c, d)\)</span> 之间的优先级, 不难得到以下优先级规则:</p>
<ol type="1">
<li><span class="math inline">\(a \times c &lt; 0\)</span> 时, 总变化量小于 <span class="math inline">\(0\)</span> 的二元组优先级更高.</li>
<li><span class="math inline">\(a &lt; 0 ,\,\, c &lt; 0\)</span> 时, 变化最大值较小的二元组优先级更高.</li>
<li><span class="math inline">\(a &gt; 0 ,\,\, c &gt; 0\)</span> 时, 总变化量减去变化最大值较小的二元组优先级更高.</li>
</ol>
<p>以上规则也可利用交换法证明正确性. 又因为任意两个二元组合并得到的新二元组不会比原来的两个二元组都更优, 所以全局最优的二元组在可以选择的时候一定会马上选择, 于是得到一个贪心策略, 每次选择最优的二元组并将其和父亲当前对应的二元组进行合并, 可以发现这样能够得到整棵树的操作序列.</p>
]]></content>
      <tags>
        <tag>Summary</tag>
        <tag>Combinatorial</tag>
      </tags>
  </entry>
</search>
